import{r as e,t}from"./graphlib-Dei5nr4o.js";import{a as n,t as r}from"./dagre-DMe0Ymih.js";import{E as i,m as a,v as o}from"./mermaid-b5860b54-GLPAaLev.js";import{t as s}from"./clone-L-XDvHbg.js";import{rt as c}from"./app-D_LQVWgZ.js";import{n as l}from"./createText-2e5e7dd3-B6-lzVZT.js";import{c as u,d,g as f,h as p,i as m,l as h,m as g,n as _,o as v,p as y,r as b,s as x,u as S}from"./edges-e0da2a9e-BNb3eoFS.js";function C(t){var n={options:{directed:t.isDirected(),multigraph:t.isMultigraph(),compound:t.isCompound()},nodes:w(t),edges:T(t)};return e(t.graph())||(n.value=s(t.graph())),n}function w(t){return n(t.nodes(),function(n){var r=t.node(n),i=t.parent(n),a={v:n};return e(r)||(a.value=r),e(i)||(a.parent=i),a})}function T(t){return n(t.edges(),function(n){var r=t.edge(n),i={v:n.v,w:n.w};return e(n.name)||(i.name=n.name),e(r)||(i.value=r),i})}var E={},D={},O={},k=()=>{D={},O={},E={}},A=(e,t)=>(i.trace(`In isDescendant`,t,` `,e,` = `,D[t].includes(e)),!!D[t].includes(e)),j=(e,t)=>(i.info(`Descendants of `,t,` is `,D[t]),i.info(`Edge is `,e),e.v===t||e.w===t?!1:D[t]?D[t].includes(e.v)||A(e.v,t)||A(e.w,t)||D[t].includes(e.w):(i.debug(`Tilt, `,t,`,not in descendants`),!1)),M=(e,t,n,r)=>{i.warn(`Copying children of `,e,`root`,r,`data`,t.node(e),r);let a=t.children(e)||[];e!==r&&a.push(e),i.warn(`Copying (nodes) clusterId`,e,`nodes`,a),a.forEach(a=>{if(t.children(a).length>0)M(a,t,n,r);else{let o=t.node(a);i.info(`cp `,a,` to `,r,` with parent `,e),n.setNode(a,o),r!==t.parent(a)&&(i.warn(`Setting parent`,a,t.parent(a)),n.setParent(a,t.parent(a))),e!==r&&a!==e?(i.debug(`Setting parent`,a,e),n.setParent(a,e)):(i.info(`In copy `,e,`root`,r,`data`,t.node(e),r),i.debug(`Not Setting parent for node=`,a,`cluster!==rootId`,e!==r,`node!==clusterId`,a!==e));let s=t.edges(a);i.debug(`Copying Edges`,s),s.forEach(a=>{i.info(`Edge`,a);let o=t.edge(a.v,a.w,a.name);i.info(`Edge data`,o,r);try{j(a,r)?(i.info(`Copying as `,a.v,a.w,o,a.name),n.setEdge(a.v,a.w,o,a.name),i.info(`newGraph edges `,n.edges(),n.edge(n.edges()[0]))):i.info(`Skipping copy of edge `,a.v,`-->`,a.w,` rootId: `,r,` clusterId:`,e)}catch(e){i.error(e)}})}i.debug(`Removing node`,a),t.removeNode(a)})},N=(e,t)=>{let n=t.children(e),r=[...n];for(let i of n)O[i]=e,r=[...r,...N(i,t)];return r},P=(e,t)=>{i.trace(`Searching`,e);let n=t.children(e);if(i.trace(`Searching children of id `,e,n),n.length<1)return i.trace(`This is a valid node`,e),e;for(let r of n){let n=P(r,t);if(n)return i.trace(`Found replacement for`,e,` => `,n),n}},F=e=>!E[e]||!E[e].externalConnections?e:E[e]?E[e].id:e,I=(e,t)=>{if(!e||t>10){i.debug(`Opting out, no graph `);return}else i.debug(`Opting in, graph `);e.nodes().forEach(function(t){e.children(t).length>0&&(i.warn(`Cluster identified`,t,` Replacement id in edges: `,P(t,e)),D[t]=N(t,e),E[t]={id:P(t,e),clusterData:e.node(t)})}),e.nodes().forEach(function(t){let n=e.children(t),r=e.edges();n.length>0?(i.debug(`Cluster identified`,t,D),r.forEach(e=>{e.v!==t&&e.w!==t&&A(e.v,t)^A(e.w,t)&&(i.warn(`Edge: `,e,` leaves cluster `,t),i.warn(`Descendants of XXX `,t,`: `,D[t]),E[t].externalConnections=!0)})):i.debug(`Not a cluster `,t,D)});for(let t of Object.keys(E)){let n=E[t].id,r=e.parent(n);r!==t&&E[r]&&!E[r].externalConnections&&(E[t].id=r)}e.edges().forEach(function(t){let n=e.edge(t);i.warn(`Edge `+t.v+` -> `+t.w+`: `+JSON.stringify(t)),i.warn(`Edge `+t.v+` -> `+t.w+`: `+JSON.stringify(e.edge(t)));let r=t.v,a=t.w;if(i.warn(`Fix XXX`,E,`ids:`,t.v,t.w,`Translating: `,E[t.v],` --- `,E[t.w]),E[t.v]&&E[t.w]&&E[t.v]===E[t.w]){i.warn(`Fixing and trixing link to self - removing XXX`,t.v,t.w,t.name),i.warn(`Fixing and trixing - removing XXX`,t.v,t.w,t.name),r=F(t.v),a=F(t.w),e.removeEdge(t.v,t.w,t.name);let o=t.w+`---`+t.v;e.setNode(o,{domId:o,id:o,labelStyle:``,labelText:n.label,padding:0,shape:`labelRect`,style:``});let s=structuredClone(n),c=structuredClone(n);s.label=``,s.arrowTypeEnd=`none`,c.label=``,s.fromCluster=t.v,c.toCluster=t.v,e.setEdge(r,o,s,t.name+`-cyclic-special`),e.setEdge(o,a,c,t.name+`-cyclic-special`)}else if(E[t.v]||E[t.w]){if(i.warn(`Fixing and trixing - removing XXX`,t.v,t.w,t.name),r=F(t.v),a=F(t.w),e.removeEdge(t.v,t.w,t.name),r!==t.v){let i=e.parent(r);E[i].externalConnections=!0,n.fromCluster=t.v}if(a!==t.w){let r=e.parent(a);E[r].externalConnections=!0,n.toCluster=t.w}i.warn(`Fix Replacing with XXX`,r,a,t.name),e.setEdge(r,a,n,t.name)}}),i.warn(`Adjusted Graph`,C(e)),L(e,0),i.trace(E)},L=(e,n)=>{if(i.warn(`extractor - `,n,C(e),e.children(`D`)),n>10){i.error(`Bailing out`);return}let r=e.nodes(),a=!1;for(let t of r){let n=e.children(t);a||=n.length>0}if(!a){i.debug(`Done, no node has children`,e.nodes());return}i.debug(`Nodes = `,r,n);for(let a of r)if(i.debug(`Extracting node`,a,E,E[a]&&!E[a].externalConnections,!e.parent(a),e.node(a),e.children(`D`),` Depth `,n),!E[a])i.debug(`Not a cluster`,a,n);else if(!E[a].externalConnections&&e.children(a)&&e.children(a).length>0){i.warn(`Cluster without external connections, without a parent and with children`,a,n);let r=e.graph().rankdir===`TB`?`LR`:`TB`;E[a]&&E[a].clusterData&&E[a].clusterData.dir&&(r=E[a].clusterData.dir,i.warn(`Fixing dir`,E[a].clusterData.dir,r));let o=new t({multigraph:!0,compound:!0}).setGraph({rankdir:r,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn(`Old graph before copy`,C(e)),M(a,e,o,a),e.setNode(a,{clusterNode:!0,id:a,clusterData:E[a].clusterData,labelText:E[a].labelText,graph:o}),i.warn(`New graph after copy node: (`,a,`)`,C(o)),i.debug(`Old graph after copy`,C(e))}else i.warn(`Cluster ** `,a,` **not meeting the criteria !externalConnections:`,!E[a].externalConnections,` no parent: `,!e.parent(a),` children `,e.children(a)&&e.children(a).length>0,e.children(`D`),n),i.debug(E);r=e.nodes(),i.warn(`New list of nodes`,r);for(let t of r){let r=e.node(t);i.warn(` Now next level`,t,r),r.clusterNode&&L(r.graph,n+1)}},R=(e,t)=>{if(t.length===0)return[];let n=Object.assign(t);return t.forEach(t=>{let r=R(e,e.children(t));n=[...n,...r]}),n},z=e=>R(e,e.children()),B={rect:(e,t)=>{i.info(`Creating subgraph rect for `,t.id,t);let n=o(),r=e.insert(`g`).attr(`class`,`cluster`+(t.class?` `+t.class:``)).attr(`id`,t.id),s=r.insert(`rect`,`:first-child`),u=a(n.flowchart.htmlLabels),f=r.insert(`g`).attr(`class`,`cluster-label`),p=t.labelType===`markdown`?l(f,t.labelText,{style:t.labelStyle,useHtmlLabels:u}):f.node().appendChild(m(t.labelText,t.labelStyle,void 0,!0)),h=p.getBBox();if(a(n.flowchart.htmlLabels)){let e=p.children[0],t=c(p);h=e.getBoundingClientRect(),t.attr(`width`,h.width),t.attr(`height`,h.height)}let g=0*t.padding,_=g/2,y=t.width<=h.width+g?h.width+g:t.width;t.width<=h.width+g?t.diff=(h.width-t.width)/2-t.padding/2:t.diff=-t.padding/2,i.trace(`Data `,t,JSON.stringify(t)),s.attr(`style`,t.style).attr(`rx`,t.rx).attr(`ry`,t.ry).attr(`x`,t.x-y/2).attr(`y`,t.y-t.height/2-_).attr(`width`,y).attr(`height`,t.height+g);let{subGraphTitleTopMargin:b}=v(n);u?f.attr(`transform`,`translate(${t.x-h.width/2}, ${t.y-t.height/2+b})`):f.attr(`transform`,`translate(${t.x}, ${t.y-t.height/2+b})`);let x=s.node().getBBox();return t.width=x.width,t.height=x.height,t.intersect=function(e){return d(t,e)},r},roundedWithTitle:(e,t)=>{let n=o(),r=e.insert(`g`).attr(`class`,t.classes).attr(`id`,t.id),i=r.insert(`rect`,`:first-child`),s=r.insert(`g`).attr(`class`,`cluster-label`),l=r.append(`rect`),u=s.node().appendChild(m(t.labelText,t.labelStyle,void 0,!0)),f=u.getBBox();if(a(n.flowchart.htmlLabels)){let e=u.children[0],t=c(u);f=e.getBoundingClientRect(),t.attr(`width`,f.width),t.attr(`height`,f.height)}f=u.getBBox();let p=0*t.padding,h=p/2,g=t.width<=f.width+t.padding?f.width+t.padding:t.width;t.width<=f.width+t.padding?t.diff=(f.width+t.padding*0-t.width)/2:t.diff=-t.padding/2,i.attr(`class`,`outer`).attr(`x`,t.x-g/2-h).attr(`y`,t.y-t.height/2-h).attr(`width`,g+p).attr(`height`,t.height+p),l.attr(`class`,`inner`).attr(`x`,t.x-g/2-h).attr(`y`,t.y-t.height/2-h+f.height-1).attr(`width`,g+p).attr(`height`,t.height+p-f.height-3);let{subGraphTitleTopMargin:_}=v(n);return s.attr(`transform`,`translate(${t.x-f.width/2}, ${t.y-t.height/2-t.padding/3+(a(n.flowchart.htmlLabels)?5:3)+_})`),t.height=i.node().getBBox().height,t.intersect=function(e){return d(t,e)},r},noteGroup:(e,t)=>{let n=e.insert(`g`).attr(`class`,`note-cluster`).attr(`id`,t.id),r=n.insert(`rect`,`:first-child`),i=0*t.padding,a=i/2;r.attr(`rx`,t.rx).attr(`ry`,t.ry).attr(`x`,t.x-t.width/2-a).attr(`y`,t.y-t.height/2-a).attr(`width`,t.width+i).attr(`height`,t.height+i).attr(`fill`,`none`);let o=r.node().getBBox();return t.width=o.width,t.height=o.height,t.intersect=function(e){return d(t,e)},n},divider:(e,t)=>{let n=e.insert(`g`).attr(`class`,t.classes).attr(`id`,t.id),r=n.insert(`rect`,`:first-child`),i=0*t.padding,a=i/2;r.attr(`class`,`divider`).attr(`x`,t.x-t.width/2-a).attr(`y`,t.y-t.height/2).attr(`width`,t.width+i).attr(`height`,t.height+i);let o=r.node().getBBox();return t.width=o.width,t.height=o.height,t.diff=-t.padding/2,t.intersect=function(e){return d(t,e)},n}},V={},H=(e,t)=>{i.trace(`Inserting cluster`);let n=t.shape||`rect`;V[t.id]=B[n](e,t)},U=()=>{V={}},W=async(e,t,n,a,o,s)=>{i.info(`Graph in recursive render: XXX`,C(t),o);let c=t.graph().rankdir;i.trace(`Dir in recursive render - dir:`,c);let l=e.insert(`g`).attr(`class`,`root`);t.nodes()?i.info(`Recursive render XXX`,t.nodes()):i.info(`No nodes found for`,t),t.edges().length>0&&i.trace(`Recursive edges`,t.edge(t.edges()[0]));let d=l.insert(`g`).attr(`class`,`clusters`),m=l.insert(`g`).attr(`class`,`edgePaths`),h=l.insert(`g`).attr(`class`,`edgeLabels`),_=l.insert(`g`).attr(`class`,`nodes`);await Promise.all(t.nodes().map(async function(e){let r=t.node(e);if(o!==void 0){let n=JSON.parse(JSON.stringify(o.clusterData));i.info(`Setting data for cluster XXX (`,e,`) `,n,o),t.setNode(o.id,n),t.parent(e)||(i.trace(`Setting parent`,e,o.id),t.setParent(e,o.id,n))}if(i.info(`(Insert) Node XXX`+e+`: `+JSON.stringify(t.node(e))),r&&r.clusterNode){i.info(`Cluster identified`,e,r.width,t.node(e));let o=await W(_,r.graph,n,a,t.node(e),s),c=o.elem;f(r,c),r.diff=o.diff||0,i.info(`Node bounds (abc123)`,e,r,r.width,r.x,r.y),p(c,r),i.warn(`Recursive render complete `,c,r)}else t.children(e).length>0?(i.info(`Cluster - the non recursive path XXX`,e,r.id,r,t),i.info(P(r.id,t)),E[r.id]={id:P(r.id,t),node:r}):(i.info(`Node - the non recursive path`,e,r.id,r),await S(_,t.node(e),c))})),t.edges().forEach(function(e){let n=t.edge(e.v,e.w,e.name);i.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(e)),i.info(`Edge `+e.v+` -> `+e.w+`: `,e,` `,JSON.stringify(t.edge(e))),i.info(`Fix`,E,`ids:`,e.v,e.w,`Translating: `,E[e.v],E[e.w]),u(h,n)}),t.edges().forEach(function(e){i.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(e))}),i.info(`#############################################`),i.info(`###                Layout                 ###`),i.info(`#############################################`),i.info(t),r(t),i.info(`Graph after layout:`,C(t));let b=0,{subGraphTitleTotalMargin:w}=v(s);return z(t).forEach(function(e){let n=t.node(e);i.info(`Position `+e+`: `+JSON.stringify(t.node(e))),i.info(`Position `+e+`: (`+n.x,`,`+n.y,`) width: `,n.width,` height: `,n.height),n&&n.clusterNode?(n.y+=w,g(n)):t.children(e).length>0?(n.height+=w,H(d,n),E[n.id].node=n):(n.y+=w/2,g(n))}),t.edges().forEach(function(e){let r=t.edge(e);i.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(r),r),r.points.forEach(e=>e.y+=w/2),y(r,x(m,e,r,E,n,t,a))}),t.nodes().forEach(function(e){let n=t.node(e);i.info(e,n.type,n.diff),n.type===`group`&&(b=n.diff)}),{elem:l,diff:b}},G=async(e,t,n,r,a)=>{h(e,n,r,a),b(),_(),U(),k(),i.warn(`Graph at first:`,JSON.stringify(C(t))),I(t),i.warn(`Graph after:`,JSON.stringify(C(t))),await W(e,t,r,a,void 0,o())};export{G as t};