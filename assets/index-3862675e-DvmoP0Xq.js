import{C as e}from"./app-BvgPJ94i.js";import{E as t,m as n,v as r}from"./mermaid-b5860b54-Dc0NswSo.js";import{r as i,t as a}from"./graphlib-CbS2pKHv.js";import{t as o}from"./clone-BCGcrB4v.js";import{n as s}from"./createText-2e5e7dd3-dnw7t4tj.js";import{c,d as l,g as u,h as d,i as f,l as p,m,n as h,o as g,p as _,r as v,s as y,u as b}from"./edges-e0da2a9e-DKrLAmCD.js";import{a as x,t as S}from"./dagre--rURG4oC.js";function C(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:w(e),edges:T(e)};return i(e.graph())||(t.value=o(e.graph())),t}function w(e){return x(e.nodes(),function(t){var n=e.node(t),r=e.parent(t),a={v:t};return i(n)||(a.value=n),i(r)||(a.parent=r),a})}function T(e){return x(e.edges(),function(t){var n=e.edge(t),r={v:t.v,w:t.w};return i(t.name)||(r.name=t.name),i(n)||(r.value=n),r})}var E={},D={},O={},k=()=>{D={},O={},E={}},A=(e,n)=>(t.trace(`In isDescendant`,n,` `,e,` = `,D[n].includes(e)),!!D[n].includes(e)),j=(e,n)=>(t.info(`Descendants of `,n,` is `,D[n]),t.info(`Edge is `,e),e.v===n||e.w===n?!1:D[n]?D[n].includes(e.v)||A(e.v,n)||A(e.w,n)||D[n].includes(e.w):(t.debug(`Tilt, `,n,`,not in descendants`),!1)),M=(e,n,r,i)=>{t.warn(`Copying children of `,e,`root`,i,`data`,n.node(e),i);let a=n.children(e)||[];e!==i&&a.push(e),t.warn(`Copying (nodes) clusterId`,e,`nodes`,a),a.forEach(a=>{if(n.children(a).length>0)M(a,n,r,i);else{let o=n.node(a);t.info(`cp `,a,` to `,i,` with parent `,e),r.setNode(a,o),i!==n.parent(a)&&(t.warn(`Setting parent`,a,n.parent(a)),r.setParent(a,n.parent(a))),e!==i&&a!==e?(t.debug(`Setting parent`,a,e),r.setParent(a,e)):(t.info(`In copy `,e,`root`,i,`data`,n.node(e),i),t.debug(`Not Setting parent for node=`,a,`cluster!==rootId`,e!==i,`node!==clusterId`,a!==e));let s=n.edges(a);t.debug(`Copying Edges`,s),s.forEach(a=>{t.info(`Edge`,a);let o=n.edge(a.v,a.w,a.name);t.info(`Edge data`,o,i);try{j(a,i)?(t.info(`Copying as `,a.v,a.w,o,a.name),r.setEdge(a.v,a.w,o,a.name),t.info(`newGraph edges `,r.edges(),r.edge(r.edges()[0]))):t.info(`Skipping copy of edge `,a.v,`-->`,a.w,` rootId: `,i,` clusterId:`,e)}catch(e){t.error(e)}})}t.debug(`Removing node`,a),n.removeNode(a)})},N=(e,t)=>{let n=t.children(e),r=[...n];for(let i of n)O[i]=e,r=[...r,...N(i,t)];return r},P=(e,n)=>{t.trace(`Searching`,e);let r=n.children(e);if(t.trace(`Searching children of id `,e,r),r.length<1)return t.trace(`This is a valid node`,e),e;for(let i of r){let r=P(i,n);if(r)return t.trace(`Found replacement for`,e,` => `,r),r}},F=e=>!E[e]||!E[e].externalConnections?e:E[e]?E[e].id:e,I=(e,n)=>{if(!e||n>10){t.debug(`Opting out, no graph `);return}else t.debug(`Opting in, graph `);e.nodes().forEach(function(n){e.children(n).length>0&&(t.warn(`Cluster identified`,n,` Replacement id in edges: `,P(n,e)),D[n]=N(n,e),E[n]={id:P(n,e),clusterData:e.node(n)})}),e.nodes().forEach(function(n){let r=e.children(n),i=e.edges();r.length>0?(t.debug(`Cluster identified`,n,D),i.forEach(e=>{e.v!==n&&e.w!==n&&A(e.v,n)^A(e.w,n)&&(t.warn(`Edge: `,e,` leaves cluster `,n),t.warn(`Descendants of XXX `,n,`: `,D[n]),E[n].externalConnections=!0)})):t.debug(`Not a cluster `,n,D)});for(let t of Object.keys(E)){let n=E[t].id,r=e.parent(n);r!==t&&E[r]&&!E[r].externalConnections&&(E[t].id=r)}e.edges().forEach(function(n){let r=e.edge(n);t.warn(`Edge `+n.v+` -> `+n.w+`: `+JSON.stringify(n)),t.warn(`Edge `+n.v+` -> `+n.w+`: `+JSON.stringify(e.edge(n)));let i=n.v,a=n.w;if(t.warn(`Fix XXX`,E,`ids:`,n.v,n.w,`Translating: `,E[n.v],` --- `,E[n.w]),E[n.v]&&E[n.w]&&E[n.v]===E[n.w]){t.warn(`Fixing and trixing link to self - removing XXX`,n.v,n.w,n.name),t.warn(`Fixing and trixing - removing XXX`,n.v,n.w,n.name),i=F(n.v),a=F(n.w),e.removeEdge(n.v,n.w,n.name);let o=n.w+`---`+n.v;e.setNode(o,{domId:o,id:o,labelStyle:``,labelText:r.label,padding:0,shape:`labelRect`,style:``});let s=structuredClone(r),c=structuredClone(r);s.label=``,s.arrowTypeEnd=`none`,c.label=``,s.fromCluster=n.v,c.toCluster=n.v,e.setEdge(i,o,s,n.name+`-cyclic-special`),e.setEdge(o,a,c,n.name+`-cyclic-special`)}else if(E[n.v]||E[n.w]){if(t.warn(`Fixing and trixing - removing XXX`,n.v,n.w,n.name),i=F(n.v),a=F(n.w),e.removeEdge(n.v,n.w,n.name),i!==n.v){let t=e.parent(i);E[t].externalConnections=!0,r.fromCluster=n.v}if(a!==n.w){let t=e.parent(a);E[t].externalConnections=!0,r.toCluster=n.w}t.warn(`Fix Replacing with XXX`,i,a,n.name),e.setEdge(i,a,r,n.name)}}),t.warn(`Adjusted Graph`,C(e)),L(e,0),t.trace(E)},L=(e,n)=>{if(t.warn(`extractor - `,n,C(e),e.children(`D`)),n>10){t.error(`Bailing out`);return}let r=e.nodes(),i=!1;for(let t of r){let n=e.children(t);i||=n.length>0}if(!i){t.debug(`Done, no node has children`,e.nodes());return}t.debug(`Nodes = `,r,n);for(let i of r)if(t.debug(`Extracting node`,i,E,E[i]&&!E[i].externalConnections,!e.parent(i),e.node(i),e.children(`D`),` Depth `,n),!E[i])t.debug(`Not a cluster`,i,n);else if(!E[i].externalConnections&&e.children(i)&&e.children(i).length>0){t.warn(`Cluster without external connections, without a parent and with children`,i,n);let r=e.graph().rankdir===`TB`?`LR`:`TB`;E[i]&&E[i].clusterData&&E[i].clusterData.dir&&(r=E[i].clusterData.dir,t.warn(`Fixing dir`,E[i].clusterData.dir,r));let o=new a({multigraph:!0,compound:!0}).setGraph({rankdir:r,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});t.warn(`Old graph before copy`,C(e)),M(i,e,o,i),e.setNode(i,{clusterNode:!0,id:i,clusterData:E[i].clusterData,labelText:E[i].labelText,graph:o}),t.warn(`New graph after copy node: (`,i,`)`,C(o)),t.debug(`Old graph after copy`,C(e))}else t.warn(`Cluster ** `,i,` **not meeting the criteria !externalConnections:`,!E[i].externalConnections,` no parent: `,!e.parent(i),` children `,e.children(i)&&e.children(i).length>0,e.children(`D`),n),t.debug(E);r=e.nodes(),t.warn(`New list of nodes`,r);for(let i of r){let r=e.node(i);t.warn(` Now next level`,i,r),r.clusterNode&&L(r.graph,n+1)}},R=(e,t)=>{if(t.length===0)return[];let n=Object.assign(t);return t.forEach(t=>{let r=R(e,e.children(t));n=[...n,...r]}),n},z=e=>R(e,e.children()),B={rect:(i,a)=>{t.info(`Creating subgraph rect for `,a.id,a);let o=r(),c=i.insert(`g`).attr(`class`,`cluster`+(a.class?` `+a.class:``)).attr(`id`,a.id),u=c.insert(`rect`,`:first-child`),d=n(o.flowchart.htmlLabels),p=c.insert(`g`).attr(`class`,`cluster-label`),m=a.labelType===`markdown`?s(p,a.labelText,{style:a.labelStyle,useHtmlLabels:d}):p.node().appendChild(f(a.labelText,a.labelStyle,void 0,!0)),h=m.getBBox();if(n(o.flowchart.htmlLabels)){let t=m.children[0],n=e(m);h=t.getBoundingClientRect(),n.attr(`width`,h.width),n.attr(`height`,h.height)}let _=0*a.padding,v=_/2,y=a.width<=h.width+_?h.width+_:a.width;a.width<=h.width+_?a.diff=(h.width-a.width)/2-a.padding/2:a.diff=-a.padding/2,t.trace(`Data `,a,JSON.stringify(a)),u.attr(`style`,a.style).attr(`rx`,a.rx).attr(`ry`,a.ry).attr(`x`,a.x-y/2).attr(`y`,a.y-a.height/2-v).attr(`width`,y).attr(`height`,a.height+_);let{subGraphTitleTopMargin:b}=g(o);d?p.attr(`transform`,`translate(${a.x-h.width/2}, ${a.y-a.height/2+b})`):p.attr(`transform`,`translate(${a.x}, ${a.y-a.height/2+b})`);let x=u.node().getBBox();return a.width=x.width,a.height=x.height,a.intersect=function(e){return l(a,e)},c},roundedWithTitle:(t,i)=>{let a=r(),o=t.insert(`g`).attr(`class`,i.classes).attr(`id`,i.id),s=o.insert(`rect`,`:first-child`),c=o.insert(`g`).attr(`class`,`cluster-label`),u=o.append(`rect`),d=c.node().appendChild(f(i.labelText,i.labelStyle,void 0,!0)),p=d.getBBox();if(n(a.flowchart.htmlLabels)){let t=d.children[0],n=e(d);p=t.getBoundingClientRect(),n.attr(`width`,p.width),n.attr(`height`,p.height)}p=d.getBBox();let m=0*i.padding,h=m/2,_=i.width<=p.width+i.padding?p.width+i.padding:i.width;i.width<=p.width+i.padding?i.diff=(p.width+i.padding*0-i.width)/2:i.diff=-i.padding/2,s.attr(`class`,`outer`).attr(`x`,i.x-_/2-h).attr(`y`,i.y-i.height/2-h).attr(`width`,_+m).attr(`height`,i.height+m),u.attr(`class`,`inner`).attr(`x`,i.x-_/2-h).attr(`y`,i.y-i.height/2-h+p.height-1).attr(`width`,_+m).attr(`height`,i.height+m-p.height-3);let{subGraphTitleTopMargin:v}=g(a);return c.attr(`transform`,`translate(${i.x-p.width/2}, ${i.y-i.height/2-i.padding/3+(n(a.flowchart.htmlLabels)?5:3)+v})`),i.height=s.node().getBBox().height,i.intersect=function(e){return l(i,e)},o},noteGroup:(e,t)=>{let n=e.insert(`g`).attr(`class`,`note-cluster`).attr(`id`,t.id),r=n.insert(`rect`,`:first-child`),i=0*t.padding,a=i/2;r.attr(`rx`,t.rx).attr(`ry`,t.ry).attr(`x`,t.x-t.width/2-a).attr(`y`,t.y-t.height/2-a).attr(`width`,t.width+i).attr(`height`,t.height+i).attr(`fill`,`none`);let o=r.node().getBBox();return t.width=o.width,t.height=o.height,t.intersect=function(e){return l(t,e)},n},divider:(e,t)=>{let n=e.insert(`g`).attr(`class`,t.classes).attr(`id`,t.id),r=n.insert(`rect`,`:first-child`),i=0*t.padding,a=i/2;r.attr(`class`,`divider`).attr(`x`,t.x-t.width/2-a).attr(`y`,t.y-t.height/2).attr(`width`,t.width+i).attr(`height`,t.height+i);let o=r.node().getBBox();return t.width=o.width,t.height=o.height,t.diff=-t.padding/2,t.intersect=function(e){return l(t,e)},n}},V={},H=(e,n)=>{t.trace(`Inserting cluster`);let r=n.shape||`rect`;V[n.id]=B[r](e,n)},U=()=>{V={}},W=async(e,n,r,i,a,o)=>{t.info(`Graph in recursive render: XXX`,C(n),a);let s=n.graph().rankdir;t.trace(`Dir in recursive render - dir:`,s);let l=e.insert(`g`).attr(`class`,`root`);n.nodes()?t.info(`Recursive render XXX`,n.nodes()):t.info(`No nodes found for`,n),n.edges().length>0&&t.trace(`Recursive edges`,n.edge(n.edges()[0]));let f=l.insert(`g`).attr(`class`,`clusters`),p=l.insert(`g`).attr(`class`,`edgePaths`),h=l.insert(`g`).attr(`class`,`edgeLabels`),v=l.insert(`g`).attr(`class`,`nodes`);await Promise.all(n.nodes().map(async function(e){let c=n.node(e);if(a!==void 0){let r=JSON.parse(JSON.stringify(a.clusterData));t.info(`Setting data for cluster XXX (`,e,`) `,r,a),n.setNode(a.id,r),n.parent(e)||(t.trace(`Setting parent`,e,a.id),n.setParent(e,a.id,r))}if(t.info(`(Insert) Node XXX`+e+`: `+JSON.stringify(n.node(e))),c&&c.clusterNode){t.info(`Cluster identified`,e,c.width,n.node(e));let a=await W(v,c.graph,r,i,n.node(e),o),s=a.elem;u(c,s),c.diff=a.diff||0,t.info(`Node bounds (abc123)`,e,c,c.width,c.x,c.y),d(s,c),t.warn(`Recursive render complete `,s,c)}else n.children(e).length>0?(t.info(`Cluster - the non recursive path XXX`,e,c.id,c,n),t.info(P(c.id,n)),E[c.id]={id:P(c.id,n),node:c}):(t.info(`Node - the non recursive path`,e,c.id,c),await b(v,n.node(e),s))})),n.edges().forEach(function(e){let r=n.edge(e.v,e.w,e.name);t.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(e)),t.info(`Edge `+e.v+` -> `+e.w+`: `,e,` `,JSON.stringify(n.edge(e))),t.info(`Fix`,E,`ids:`,e.v,e.w,`Translating: `,E[e.v],E[e.w]),c(h,r)}),n.edges().forEach(function(e){t.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(e))}),t.info(`#############################################`),t.info(`###                Layout                 ###`),t.info(`#############################################`),t.info(n),S(n),t.info(`Graph after layout:`,C(n));let x=0,{subGraphTitleTotalMargin:w}=g(o);return z(n).forEach(function(e){let r=n.node(e);t.info(`Position `+e+`: `+JSON.stringify(n.node(e))),t.info(`Position `+e+`: (`+r.x,`,`+r.y,`) width: `,r.width,` height: `,r.height),r&&r.clusterNode?(r.y+=w,m(r)):n.children(e).length>0?(r.height+=w,H(f,r),E[r.id].node=r):(r.y+=w/2,m(r))}),n.edges().forEach(function(e){let a=n.edge(e);t.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(a),a),a.points.forEach(e=>e.y+=w/2),_(a,y(p,e,a,E,r,n,i))}),n.nodes().forEach(function(e){let r=n.node(e);t.info(e,r.type,r.diff),r.type===`group`&&(x=r.diff)}),{elem:l,diff:x}},G=async(e,n,i,a,o)=>{p(e,i,a,o),v(),h(),U(),k(),t.warn(`Graph at first:`,JSON.stringify(C(n))),I(n),t.warn(`Graph after:`,JSON.stringify(C(n))),await W(e,n,a,o,void 0,r())};export{G as t};